// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace CognitiveSearch.Models
{
    /// <summary> Model factory for read-only models. </summary>
    public static partial class CognitiveServicesModelFactory
    {
        /// <summary> Initializes a new instance of SearchDocumentsResult. </summary>
        /// <param name="count"> The total count of results found by the search operation, or null if the count was not requested. If present, the count may be greater than the number of results in this response. This can happen if you use the $top or $skip parameters, or if Azure Cognitive Search can&apos;t return all the requested documents in a single Search response. </param>
        /// <param name="coverage"> A value indicating the percentage of the index that was included in the query, or null if minimumCoverage was not specified in the request. </param>
        /// <param name="facets"> The facet query results for the search operation, organized as a collection of buckets for each faceted field; null if the query did not include any facet expressions. </param>
        /// <param name="nextPageParameters"> Continuation JSON payload returned when Azure Cognitive Search can&apos;t return all the requested results in a single Search response. You can use this JSON along with @odata.nextLink to formulate another POST Search request to get the next part of the search response. </param>
        /// <param name="results"> The sequence of results returned by the query. </param>
        /// <param name="nextLink"> Continuation URL returned when Azure Cognitive Search can&apos;t return all the requested results in a single Search response. You can use this URL to formulate another GET or POST Search request to get the next part of the search response. Make sure to use the same verb (GET or POST) as the request that produced this response. </param>
        /// <returns> A new <see cref="Models.SearchDocumentsResult"/> instance for mocking. </returns>
        public static SearchDocumentsResult SearchDocumentsResult(long? count = null, double? coverage = null, IReadOnlyDictionary<string, IList<FacetResult>> facets = null, SearchRequest nextPageParameters = null, IEnumerable<SearchResult> results = null, string nextLink = null)
        {
            facets ??= new Dictionary<string, IList<FacetResult>>();
            results ??= new List<SearchResult>();

            return new SearchDocumentsResult(count, coverage, facets, nextPageParameters, results?.ToList(), nextLink);
        }

        /// <summary> Initializes a new instance of FacetResult. </summary>
        /// <param name="count"> The approximate count of documents falling within the bucket described by this facet. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Models.FacetResult"/> instance for mocking. </returns>
        public static FacetResult FacetResult(long? count = null, IReadOnlyDictionary<string, object> additionalProperties = null)
        {
            additionalProperties ??= new Dictionary<string, object>();

            return new FacetResult(count, additionalProperties);
        }

        /// <summary> Initializes a new instance of SearchRequest. </summary>
        /// <param name="includeTotalResultCount"> A value that specifies whether to fetch the total count of results. Default is false. Setting this value to true may have a performance impact. Note that the count returned is an approximation. </param>
        /// <param name="facets"> The list of facet expressions to apply to the search query. Each facet expression contains a field name, optionally followed by a comma-separated list of name:value pairs. </param>
        /// <param name="filter"> The OData $filter expression to apply to the search query. </param>
        /// <param name="highlightFields"> The comma-separated list of field names to use for hit highlights. Only searchable fields can be used for hit highlighting. </param>
        /// <param name="highlightPostTag"> A string tag that is appended to hit highlights. Must be set with highlightPreTag. Default is &amp;lt;/em&amp;gt;. </param>
        /// <param name="highlightPreTag"> A string tag that is prepended to hit highlights. Must be set with highlightPostTag. Default is &amp;lt;em&amp;gt;. </param>
        /// <param name="minimumCoverage"> A number between 0 and 100 indicating the percentage of the index that must be covered by a search query in order for the query to be reported as a success. This parameter can be useful for ensuring search availability even for services with only one replica. The default is 100. </param>
        /// <param name="orderBy"> The comma-separated list of OData $orderby expressions by which to sort the results. Each expression can be either a field name or a call to either the geo.distance() or the search.score() functions. Each expression can be followed by asc to indicate ascending, or desc to indicate descending. The default is ascending order. Ties will be broken by the match scores of documents. If no $orderby is specified, the default sort order is descending by document match score. There can be at most 32 $orderby clauses. </param>
        /// <param name="queryType"> A value that specifies the syntax of the search query. The default is &apos;simple&apos;. Use &apos;full&apos; if your query uses the Lucene query syntax. </param>
        /// <param name="scoringParameters"> The list of parameter values to be used in scoring functions (for example, referencePointParameter) using the format name-values. For example, if the scoring profile defines a function with a parameter called &apos;mylocation&apos; the parameter string would be &quot;mylocation--122.2,44.8&quot; (without the quotes). </param>
        /// <param name="scoringProfile"> The name of a scoring profile to evaluate match scores for matching documents in order to sort the results. </param>
        /// <param name="searchText"> A full-text search query expression; Use &quot;*&quot; or omit this parameter to match all documents. </param>
        /// <param name="searchFields"> The comma-separated list of field names to which to scope the full-text search. When using fielded search (fieldName:searchExpression) in a full Lucene query, the field names of each fielded search expression take precedence over any field names listed in this parameter. </param>
        /// <param name="searchMode"> A value that specifies whether any or all of the search terms must be matched in order to count the document as a match. </param>
        /// <param name="select"> The comma-separated list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema are included. </param>
        /// <param name="skip"> The number of search results to skip. This value cannot be greater than 100,000. If you need to scan documents in sequence, but cannot use skip due to this limitation, consider using orderby on a totally-ordered key and filter with a range query instead. </param>
        /// <param name="top"> The number of search results to retrieve. This can be used in conjunction with $skip to implement client-side paging of search results. If results are truncated due to server-side paging, the response will include a continuation token that can be used to issue another Search request for the next page of results. </param>
        /// <returns> A new <see cref="Models.SearchRequest"/> instance for mocking. </returns>
        public static SearchRequest SearchRequest(bool? includeTotalResultCount = null, IEnumerable<string> facets = null, string filter = null, string highlightFields = null, string highlightPostTag = null, string highlightPreTag = null, double? minimumCoverage = null, string orderBy = null, QueryType? queryType = null, IEnumerable<string> scoringParameters = null, string scoringProfile = null, string searchText = null, string searchFields = null, SearchMode? searchMode = null, string select = null, int? skip = null, int? top = null)
        {
            facets ??= new List<string>();
            scoringParameters ??= new List<string>();

            return new SearchRequest(includeTotalResultCount, facets?.ToList(), filter, highlightFields, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, queryType, scoringParameters?.ToList(), scoringProfile, searchText, searchFields, searchMode, select, skip, top);
        }

        /// <summary> Initializes a new instance of SearchResult. </summary>
        /// <param name="score"> The relevance score of the document compared to other documents returned by the query. </param>
        /// <param name="highlights"> Text fragments from the document that indicate the matching search terms, organized by each applicable field; null if hit highlighting was not enabled for the query. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Models.SearchResult"/> instance for mocking. </returns>
        public static SearchResult SearchResult(double score = default, IReadOnlyDictionary<string, IList<string>> highlights = null, IReadOnlyDictionary<string, object> additionalProperties = null)
        {
            highlights ??= new Dictionary<string, IList<string>>();
            additionalProperties ??= new Dictionary<string, object>();

            return new SearchResult(score, highlights, additionalProperties);
        }

        /// <summary> Initializes a new instance of SuggestDocumentsResult. </summary>
        /// <param name="results"> The sequence of results returned by the query. </param>
        /// <param name="coverage"> A value indicating the percentage of the index that was included in the query, or null if minimumCoverage was not set in the request. </param>
        /// <returns> A new <see cref="Models.SuggestDocumentsResult"/> instance for mocking. </returns>
        public static SuggestDocumentsResult SuggestDocumentsResult(IEnumerable<SuggestResult> results = null, double? coverage = null)
        {
            results ??= new List<SuggestResult>();

            return new SuggestDocumentsResult(results?.ToList(), coverage);
        }

        /// <summary> Initializes a new instance of SuggestResult. </summary>
        /// <param name="text"> The text of the suggestion result. </param>
        /// <param name="additionalProperties"> Additional Properties. </param>
        /// <returns> A new <see cref="Models.SuggestResult"/> instance for mocking. </returns>
        public static SuggestResult SuggestResult(string text = null, IReadOnlyDictionary<string, object> additionalProperties = null)
        {
            additionalProperties ??= new Dictionary<string, object>();

            return new SuggestResult(text, additionalProperties);
        }

        /// <summary> Initializes a new instance of IndexDocumentsResult. </summary>
        /// <param name="results"> The list of status information for each document in the indexing request. </param>
        /// <returns> A new <see cref="Models.IndexDocumentsResult"/> instance for mocking. </returns>
        public static IndexDocumentsResult IndexDocumentsResult(IEnumerable<IndexingResult> results = null)
        {
            results ??= new List<IndexingResult>();

            return new IndexDocumentsResult(results?.ToList());
        }

        /// <summary> Initializes a new instance of IndexingResult. </summary>
        /// <param name="key"> The key of a document that was in the indexing request. </param>
        /// <param name="errorMessage"> The error message explaining why the indexing operation failed for the document identified by the key; null if indexing succeeded. </param>
        /// <param name="succeeded"> A value indicating whether the indexing operation succeeded for the document identified by the key. </param>
        /// <param name="statusCode"> The status code of the indexing operation. Possible values include: 200 for a successful update or delete, 201 for successful document creation, 400 for a malformed input document, 404 for document not found, 409 for a version conflict, 422 when the index is temporarily unavailable, or 503 for when the service is too busy. </param>
        /// <returns> A new <see cref="Models.IndexingResult"/> instance for mocking. </returns>
        public static IndexingResult IndexingResult(string key = null, string errorMessage = null, bool succeeded = default, int statusCode = default)
        {
            return new IndexingResult(key, errorMessage, succeeded, statusCode);
        }

        /// <summary> Initializes a new instance of AutocompleteResult. </summary>
        /// <param name="coverage"> A value indicating the percentage of the index that was considered by the autocomplete request, or null if minimumCoverage was not specified in the request. </param>
        /// <param name="results"> The list of returned Autocompleted items. </param>
        /// <returns> A new <see cref="Models.AutocompleteResult"/> instance for mocking. </returns>
        public static AutocompleteResult AutocompleteResult(double? coverage = null, IEnumerable<AutocompleteItem> results = null)
        {
            results ??= new List<AutocompleteItem>();

            return new AutocompleteResult(coverage, results?.ToList());
        }

        /// <summary> Initializes a new instance of AutocompleteItem. </summary>
        /// <param name="text"> The completed term. </param>
        /// <param name="queryPlusText"> The query along with the completed term. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="text"/> or <paramref name="queryPlusText"/> is null. </exception>
        /// <returns> A new <see cref="Models.AutocompleteItem"/> instance for mocking. </returns>
        public static AutocompleteItem AutocompleteItem(string text = null, string queryPlusText = null)
        {
            if (text == null)
            {
                throw new ArgumentNullException(nameof(text));
            }
            if (queryPlusText == null)
            {
                throw new ArgumentNullException(nameof(queryPlusText));
            }

            return new AutocompleteItem(text, queryPlusText);
        }

        /// <summary> Initializes a new instance of DataSource. </summary>
        /// <param name="name"> The name of the datasource. </param>
        /// <param name="description"> The description of the datasource. </param>
        /// <param name="type"> The type of the datasource. </param>
        /// <param name="credentials"> Credentials for the datasource. </param>
        /// <param name="container"> The data container for the datasource. </param>
        /// <param name="dataChangeDetectionPolicy">
        /// The data change detection policy for the datasource.
        /// Please note <see cref="DataChangeDetectionPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="HighWaterMarkChangeDetectionPolicy"/> and <see cref="SqlIntegratedChangeTrackingPolicy"/>.
        /// </param>
        /// <param name="dataDeletionDetectionPolicy">
        /// The data deletion detection policy for the datasource.
        /// Please note <see cref="DataDeletionDetectionPolicy"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="SoftDeleteColumnDeletionDetectionPolicy"/>.
        /// </param>
        /// <param name="eTag"> The ETag of the DataSource. </param>
        /// <returns> A new <see cref="Models.DataSource"/> instance for mocking. </returns>
        public static DataSource DataSource(string name = null, string description = null, DataSourceType type = default, DataSourceCredentials credentials = null, DataContainer container = null, DataChangeDetectionPolicy dataChangeDetectionPolicy = null, DataDeletionDetectionPolicy dataDeletionDetectionPolicy = null, string eTag = null)
        {
            return new DataSource(name, description, type, credentials, container, dataChangeDetectionPolicy, dataDeletionDetectionPolicy, eTag);
        }

        /// <summary> Initializes a new instance of DataSourceCredentials. </summary>
        /// <param name="connectionString"> The connection string for the datasource. </param>
        /// <returns> A new <see cref="Models.DataSourceCredentials"/> instance for mocking. </returns>
        public static DataSourceCredentials DataSourceCredentials(string connectionString = null)
        {
            return new DataSourceCredentials(connectionString);
        }

        /// <summary> Initializes a new instance of DataContainer. </summary>
        /// <param name="name"> The name of the table or view (for Azure SQL data source) or collection (for CosmosDB data source) that will be indexed. </param>
        /// <param name="query"> A query that is applied to this data container. The syntax and meaning of this parameter is datasource-specific. Not supported by Azure SQL datasources. </param>
        /// <returns> A new <see cref="Models.DataContainer"/> instance for mocking. </returns>
        public static DataContainer DataContainer(string name = null, string query = null)
        {
            return new DataContainer(name, query);
        }

        /// <summary> Initializes a new instance of DataChangeDetectionPolicy. </summary>
        /// <param name="odataType"> Identifies the concrete type of the data change detection policy. </param>
        /// <returns> A new <see cref="Models.DataChangeDetectionPolicy"/> instance for mocking. </returns>
        public static DataChangeDetectionPolicy DataChangeDetectionPolicy(string odataType = null)
        {
            return new UnknownDataChangeDetectionPolicy(odataType);
        }

        /// <summary> Initializes a new instance of DataDeletionDetectionPolicy. </summary>
        /// <param name="odataType"> Identifies the concrete type of the data deletion detection policy. </param>
        /// <returns> A new <see cref="Models.DataDeletionDetectionPolicy"/> instance for mocking. </returns>
        public static DataDeletionDetectionPolicy DataDeletionDetectionPolicy(string odataType = null)
        {
            return new UnknownDataDeletionDetectionPolicy(odataType);
        }

        /// <summary> Initializes a new instance of ListDataSourcesResult. </summary>
        /// <param name="dataSources"> The datasources in the Search service. </param>
        /// <returns> A new <see cref="Models.ListDataSourcesResult"/> instance for mocking. </returns>
        public static ListDataSourcesResult ListDataSourcesResult(IEnumerable<DataSource> dataSources = null)
        {
            dataSources ??= new List<DataSource>();

            return new ListDataSourcesResult(dataSources?.ToList());
        }

        /// <summary> Initializes a new instance of Indexer. </summary>
        /// <param name="name"> The name of the indexer. </param>
        /// <param name="description"> The description of the indexer. </param>
        /// <param name="dataSourceName"> The name of the datasource from which this indexer reads data. </param>
        /// <param name="skillsetName"> The name of the skillset executing with this indexer. </param>
        /// <param name="targetIndexName"> The name of the index to which this indexer writes data. </param>
        /// <param name="schedule"> The schedule for this indexer. </param>
        /// <param name="parameters"> Parameters for indexer execution. </param>
        /// <param name="fieldMappings"> Defines mappings between fields in the data source and corresponding target fields in the index. </param>
        /// <param name="outputFieldMappings"> Output field mappings are applied after enrichment and immediately before indexing. </param>
        /// <param name="isDisabled"> A value indicating whether the indexer is disabled. Default is false. </param>
        /// <param name="eTag"> The ETag of the Indexer. </param>
        /// <returns> A new <see cref="Models.Indexer"/> instance for mocking. </returns>
        public static Indexer Indexer(string name = null, string description = null, string dataSourceName = null, string skillsetName = null, string targetIndexName = null, IndexingSchedule schedule = null, IndexingParameters parameters = null, IEnumerable<FieldMapping> fieldMappings = null, IEnumerable<FieldMapping> outputFieldMappings = null, bool? isDisabled = null, string eTag = null)
        {
            fieldMappings ??= new List<FieldMapping>();
            outputFieldMappings ??= new List<FieldMapping>();

            return new Indexer(name, description, dataSourceName, skillsetName, targetIndexName, schedule, parameters, fieldMappings?.ToList(), outputFieldMappings?.ToList(), isDisabled, eTag);
        }

        /// <summary> Initializes a new instance of IndexingSchedule. </summary>
        /// <param name="interval"> The interval of time between indexer executions. </param>
        /// <param name="startTime"> The time when an indexer should start running. </param>
        /// <returns> A new <see cref="Models.IndexingSchedule"/> instance for mocking. </returns>
        public static IndexingSchedule IndexingSchedule(TimeSpan interval = default, DateTimeOffset? startTime = null)
        {
            return new IndexingSchedule(interval, startTime);
        }

        /// <summary> Initializes a new instance of IndexingParameters. </summary>
        /// <param name="batchSize"> The number of items that are read from the data source and indexed as a single batch in order to improve performance. The default depends on the data source type. </param>
        /// <param name="maxFailedItems"> The maximum number of items that can fail indexing for indexer execution to still be considered successful. -1 means no limit. Default is 0. </param>
        /// <param name="maxFailedItemsPerBatch"> The maximum number of items in a single batch that can fail indexing for the batch to still be considered successful. -1 means no limit. Default is 0. </param>
        /// <param name="configuration"> A dictionary of indexer-specific configuration properties. Each name is the name of a specific property. Each value must be of a primitive type. </param>
        /// <returns> A new <see cref="Models.IndexingParameters"/> instance for mocking. </returns>
        public static IndexingParameters IndexingParameters(int? batchSize = null, int? maxFailedItems = null, int? maxFailedItemsPerBatch = null, IDictionary<string, object> configuration = null)
        {
            configuration ??= new Dictionary<string, object>();

            return new IndexingParameters(batchSize, maxFailedItems, maxFailedItemsPerBatch, configuration);
        }

        /// <summary> Initializes a new instance of FieldMapping. </summary>
        /// <param name="sourceFieldName"> The name of the field in the data source. </param>
        /// <param name="targetFieldName"> The name of the target field in the index. Same as the source field name by default. </param>
        /// <param name="mappingFunction"> A function to apply to each source field value before indexing. </param>
        /// <returns> A new <see cref="Models.FieldMapping"/> instance for mocking. </returns>
        public static FieldMapping FieldMapping(string sourceFieldName = null, string targetFieldName = null, FieldMappingFunction mappingFunction = null)
        {
            return new FieldMapping(sourceFieldName, targetFieldName, mappingFunction);
        }

        /// <summary> Initializes a new instance of FieldMappingFunction. </summary>
        /// <param name="name"> The name of the field mapping function. </param>
        /// <param name="parameters"> A dictionary of parameter name/value pairs to pass to the function. Each value must be of a primitive type. </param>
        /// <returns> A new <see cref="Models.FieldMappingFunction"/> instance for mocking. </returns>
        public static FieldMappingFunction FieldMappingFunction(string name = null, IDictionary<string, object> parameters = null)
        {
            parameters ??= new Dictionary<string, object>();

            return new FieldMappingFunction(name, parameters);
        }

        /// <summary> Initializes a new instance of ListIndexersResult. </summary>
        /// <param name="indexers"> The indexers in the Search service. </param>
        /// <returns> A new <see cref="Models.ListIndexersResult"/> instance for mocking. </returns>
        public static ListIndexersResult ListIndexersResult(IEnumerable<Indexer> indexers = null)
        {
            indexers ??= new List<Indexer>();

            return new ListIndexersResult(indexers?.ToList());
        }

        /// <summary> Initializes a new instance of IndexerExecutionInfo. </summary>
        /// <param name="status"> Overall indexer status. </param>
        /// <param name="lastResult"> The result of the most recent or an in-progress indexer execution. </param>
        /// <param name="executionHistory"> History of the recent indexer executions, sorted in reverse chronological order. </param>
        /// <param name="limits"> The execution limits for the indexer. </param>
        /// <returns> A new <see cref="Models.IndexerExecutionInfo"/> instance for mocking. </returns>
        public static IndexerExecutionInfo IndexerExecutionInfo(IndexerStatus status = default, IndexerExecutionResult lastResult = null, IEnumerable<IndexerExecutionResult> executionHistory = null, IndexerLimits limits = null)
        {
            executionHistory ??= new List<IndexerExecutionResult>();

            return new IndexerExecutionInfo(status, lastResult, executionHistory?.ToList(), limits);
        }

        /// <summary> Initializes a new instance of IndexerExecutionResult. </summary>
        /// <param name="status"> The outcome of this indexer execution. </param>
        /// <param name="errorMessage"> The error message indicating the top-level error, if any. </param>
        /// <param name="startTime"> The start time of this indexer execution. </param>
        /// <param name="endTime"> The end time of this indexer execution, if the execution has already completed. </param>
        /// <param name="errors"> The item-level indexing errors. </param>
        /// <param name="warnings"> The item-level indexing warnings. </param>
        /// <param name="itemCount"> The number of items that were processed during this indexer execution. This includes both successfully processed items and items where indexing was attempted but failed. </param>
        /// <param name="failedItemCount"> The number of items that failed to be indexed during this indexer execution. </param>
        /// <param name="initialTrackingState"> Change tracking state with which an indexer execution started. </param>
        /// <param name="finalTrackingState"> Change tracking state with which an indexer execution finished. </param>
        /// <returns> A new <see cref="Models.IndexerExecutionResult"/> instance for mocking. </returns>
        public static IndexerExecutionResult IndexerExecutionResult(IndexerExecutionStatus status = default, string errorMessage = null, DateTimeOffset? startTime = null, DateTimeOffset? endTime = null, IEnumerable<ItemError> errors = null, IEnumerable<ItemWarning> warnings = null, int itemCount = default, int failedItemCount = default, string initialTrackingState = null, string finalTrackingState = null)
        {
            errors ??= new List<ItemError>();
            warnings ??= new List<ItemWarning>();

            return new IndexerExecutionResult(status, errorMessage, startTime, endTime, errors?.ToList(), warnings?.ToList(), itemCount, failedItemCount, initialTrackingState, finalTrackingState);
        }

        /// <summary> Initializes a new instance of ItemError. </summary>
        /// <param name="key"> The key of the item for which indexing failed. </param>
        /// <param name="errorMessage"> The message describing the error that occurred while processing the item. </param>
        /// <param name="statusCode"> The status code indicating why the indexing operation failed. Possible values include: 400 for a malformed input document, 404 for document not found, 409 for a version conflict, 422 when the index is temporarily unavailable, or 503 for when the service is too busy. </param>
        /// <param name="name"> The name of the source at which the error originated. For example, this could refer to a particular skill in the attached skillset. This may not be always available. </param>
        /// <param name="details"> Additional, verbose details about the error to assist in debugging the indexer. This may not be always available. </param>
        /// <param name="documentationLink"> A link to a troubleshooting guide for these classes of errors. This may not be always available. </param>
        /// <returns> A new <see cref="Models.ItemError"/> instance for mocking. </returns>
        public static ItemError ItemError(string key = null, string errorMessage = null, int statusCode = default, string name = null, string details = null, string documentationLink = null)
        {
            return new ItemError(key, errorMessage, statusCode, name, details, documentationLink);
        }

        /// <summary> Initializes a new instance of ItemWarning. </summary>
        /// <param name="key"> The key of the item which generated a warning. </param>
        /// <param name="message"> The message describing the warning that occurred while processing the item. </param>
        /// <param name="name"> The name of the source at which the warning originated. For example, this could refer to a particular skill in the attached skillset. This may not be always available. </param>
        /// <param name="details"> Additional, verbose details about the warning to assist in debugging the indexer. This may not be always available. </param>
        /// <param name="documentationLink"> A link to a troubleshooting guide for these classes of warnings. This may not be always available. </param>
        /// <returns> A new <see cref="Models.ItemWarning"/> instance for mocking. </returns>
        public static ItemWarning ItemWarning(string key = null, string message = null, string name = null, string details = null, string documentationLink = null)
        {
            return new ItemWarning(key, message, name, details, documentationLink);
        }

        /// <summary> Initializes a new instance of IndexerLimits. </summary>
        /// <param name="maxRunTime"> The maximum duration that the indexer is permitted to run for one execution. </param>
        /// <param name="maxDocumentExtractionSize"> The maximum size of a document, in bytes, which will be considered valid for indexing. </param>
        /// <param name="maxDocumentContentCharactersToExtract"> The maximum number of characters that will be extracted from a document picked up for indexing. </param>
        /// <returns> A new <see cref="Models.IndexerLimits"/> instance for mocking. </returns>
        public static IndexerLimits IndexerLimits(TimeSpan? maxRunTime = null, long? maxDocumentExtractionSize = null, long? maxDocumentContentCharactersToExtract = null)
        {
            return new IndexerLimits(maxRunTime, maxDocumentExtractionSize, maxDocumentContentCharactersToExtract);
        }

        /// <summary> Initializes a new instance of Skillset. </summary>
        /// <param name="name"> The name of the skillset. </param>
        /// <param name="description"> The description of the skillset. </param>
        /// <param name="skills">
        /// A list of skills in the skillset.
        /// Please note <see cref="Skill"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="WebApiSkill"/>, <see cref="EntityRecognitionSkill"/>, <see cref="KeyPhraseExtractionSkill"/>, <see cref="LanguageDetectionSkill"/>, <see cref="MergeSkill"/>, <see cref="SentimentSkill"/>, <see cref="SplitSkill"/>, <see cref="TextTranslationSkill"/>, <see cref="ConditionalSkill"/>, <see cref="ShaperSkill"/>, <see cref="ImageAnalysisSkill"/> and <see cref="OcrSkill"/>.
        /// </param>
        /// <param name="cognitiveServicesAccount">
        /// Details about cognitive services to be used when running skills.
        /// Please note <see cref="CognitiveServicesAccount"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="CognitiveServicesAccountKey"/> and <see cref="DefaultCognitiveServicesAccount"/>.
        /// </param>
        /// <param name="eTag"> The ETag of the skillset. </param>
        /// <returns> A new <see cref="Models.Skillset"/> instance for mocking. </returns>
        public static Skillset Skillset(string name = null, string description = null, IEnumerable<Skill> skills = null, CognitiveServicesAccount cognitiveServicesAccount = null, string eTag = null)
        {
            skills ??= new List<Skill>();

            return new Skillset(name, description, skills?.ToList(), cognitiveServicesAccount, eTag);
        }

        /// <summary> Initializes a new instance of Skill. </summary>
        /// <param name="odataType"> Identifies the concrete type of the skill. </param>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <returns> A new <see cref="Models.Skill"/> instance for mocking. </returns>
        public static Skill Skill(string odataType = null, string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new UnknownSkill(odataType, name, description, context, inputs?.ToList(), outputs?.ToList());
        }

        /// <summary> Initializes a new instance of InputFieldMappingEntry. </summary>
        /// <param name="name"> The name of the input. </param>
        /// <param name="source"> The source of the input. </param>
        /// <param name="sourceContext"> The source context used for selecting recursive inputs. </param>
        /// <param name="inputs"> The recursive inputs used when creating a complex type. </param>
        /// <returns> A new <see cref="Models.InputFieldMappingEntry"/> instance for mocking. </returns>
        public static InputFieldMappingEntry InputFieldMappingEntry(string name = null, string source = null, string sourceContext = null, IEnumerable<InputFieldMappingEntry> inputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();

            return new InputFieldMappingEntry(name, source, sourceContext, inputs?.ToList());
        }

        /// <summary> Initializes a new instance of OutputFieldMappingEntry. </summary>
        /// <param name="name"> The name of the output defined by the skill. </param>
        /// <param name="targetName"> The target name of the output. It is optional and default to name. </param>
        /// <returns> A new <see cref="Models.OutputFieldMappingEntry"/> instance for mocking. </returns>
        public static OutputFieldMappingEntry OutputFieldMappingEntry(string name = null, string targetName = null)
        {
            return new OutputFieldMappingEntry(name, targetName);
        }

        /// <summary> Initializes a new instance of CognitiveServicesAccount. </summary>
        /// <param name="odataType"> Identifies the concrete type of the cognitive service resource attached to a skillset. </param>
        /// <param name="description"> Description of the cognitive service resource attached to a skillset. </param>
        /// <returns> A new <see cref="Models.CognitiveServicesAccount"/> instance for mocking. </returns>
        public static CognitiveServicesAccount CognitiveServicesAccount(string odataType = null, string description = null)
        {
            return new UnknownCognitiveServicesAccount(odataType, description);
        }

        /// <summary> Initializes a new instance of ListSkillsetsResult. </summary>
        /// <param name="skillsets"> The skillsets defined in the Search service. </param>
        /// <returns> A new <see cref="Models.ListSkillsetsResult"/> instance for mocking. </returns>
        public static ListSkillsetsResult ListSkillsetsResult(IEnumerable<Skillset> skillsets = null)
        {
            skillsets ??= new List<Skillset>();

            return new ListSkillsetsResult(skillsets?.ToList());
        }

        /// <summary> Initializes a new instance of SynonymMap. </summary>
        /// <param name="name"> The name of the synonym map. </param>
        /// <param name="format"> The format of the synonym map. Only the &apos;solr&apos; format is currently supported. </param>
        /// <param name="synonyms"> A series of synonym rules in the specified synonym map format. The rules must be separated by newlines. </param>
        /// <param name="encryptionKey"> A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your data when you want full assurance that no one, not even Microsoft, can decrypt your data in Azure Cognitive Search. Once you have encrypted your data, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your data will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. </param>
        /// <param name="eTag"> The ETag of the synonym map. </param>
        /// <returns> A new <see cref="Models.SynonymMap"/> instance for mocking. </returns>
        public static SynonymMap SynonymMap(string name = null, string format = null, string synonyms = null, EncryptionKey encryptionKey = null, string eTag = null)
        {
            return new SynonymMap(name, format, synonyms, encryptionKey, eTag);
        }

        /// <summary> Initializes a new instance of EncryptionKey. </summary>
        /// <param name="keyVaultKeyName"> The name of your Azure Key Vault key to be used to encrypt your data at rest. </param>
        /// <param name="keyVaultKeyVersion"> The version of your Azure Key Vault key to be used to encrypt your data at rest. </param>
        /// <param name="keyVaultUri"> The URI of your Azure Key Vault, also referred to as DNS name, that contains the key to be used to encrypt your data at rest. An example URI might be https://my-keyvault-name.vault.azure.net. </param>
        /// <param name="accessCredentials"> Optional Azure Active Directory credentials used for accessing your Azure Key Vault. Not required if using managed identity instead. </param>
        /// <returns> A new <see cref="Models.EncryptionKey"/> instance for mocking. </returns>
        public static EncryptionKey EncryptionKey(string keyVaultKeyName = null, string keyVaultKeyVersion = null, string keyVaultUri = null, AzureActiveDirectoryApplicationCredentials accessCredentials = null)
        {
            return new EncryptionKey(keyVaultKeyName, keyVaultKeyVersion, keyVaultUri, accessCredentials);
        }

        /// <summary> Initializes a new instance of AzureActiveDirectoryApplicationCredentials. </summary>
        /// <param name="applicationId"> An AAD Application ID that was granted the required access permissions to the Azure Key Vault that is to be used when encrypting your data at rest. The Application ID should not be confused with the Object ID for your AAD Application. </param>
        /// <param name="applicationSecret"> The authentication key of the specified AAD application. </param>
        /// <returns> A new <see cref="Models.AzureActiveDirectoryApplicationCredentials"/> instance for mocking. </returns>
        public static AzureActiveDirectoryApplicationCredentials AzureActiveDirectoryApplicationCredentials(string applicationId = null, string applicationSecret = null)
        {
            return new AzureActiveDirectoryApplicationCredentials(applicationId, applicationSecret);
        }

        /// <summary> Initializes a new instance of ListSynonymMapsResult. </summary>
        /// <param name="synonymMaps"> The synonym maps in the Search service. </param>
        /// <returns> A new <see cref="Models.ListSynonymMapsResult"/> instance for mocking. </returns>
        public static ListSynonymMapsResult ListSynonymMapsResult(IEnumerable<SynonymMap> synonymMaps = null)
        {
            synonymMaps ??= new List<SynonymMap>();

            return new ListSynonymMapsResult(synonymMaps?.ToList());
        }

        /// <summary> Initializes a new instance of Index. </summary>
        /// <param name="name"> The name of the index. </param>
        /// <param name="fields"> The fields of the index. </param>
        /// <param name="scoringProfiles"> The scoring profiles for the index. </param>
        /// <param name="defaultScoringProfile"> The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used. </param>
        /// <param name="corsOptions"> Options to control Cross-Origin Resource Sharing (CORS) for the index. </param>
        /// <param name="suggesters"> The suggesters for the index. </param>
        /// <param name="analyzers">
        /// The analyzers for the index.
        /// Please note <see cref="Analyzer"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="CustomAnalyzer"/>, <see cref="PatternAnalyzer"/>, <see cref="StandardAnalyzer"/> and <see cref="StopAnalyzer"/>.
        /// </param>
        /// <param name="tokenizers">
        /// The tokenizers for the index.
        /// Please note <see cref="Tokenizer"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ClassicTokenizer"/>, <see cref="EdgeNGramTokenizer"/>, <see cref="KeywordTokenizer"/>, <see cref="KeywordTokenizerV2"/>, <see cref="MicrosoftLanguageStemmingTokenizer"/>, <see cref="MicrosoftLanguageTokenizer"/>, <see cref="NGramTokenizer"/>, <see cref="PathHierarchyTokenizerV2"/>, <see cref="PatternTokenizer"/>, <see cref="StandardTokenizer"/>, <see cref="StandardTokenizerV2"/> and <see cref="UaxUrlEmailTokenizer"/>.
        /// </param>
        /// <param name="tokenFilters">
        /// The token filters for the index.
        /// Please note <see cref="TokenFilter"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="AsciiFoldingTokenFilter"/>, <see cref="CjkBigramTokenFilter"/>, <see cref="CommonGramTokenFilter"/>, <see cref="DictionaryDecompounderTokenFilter"/>, <see cref="EdgeNGramTokenFilter"/>, <see cref="EdgeNGramTokenFilterV2"/>, <see cref="ElisionTokenFilter"/>, <see cref="KeepTokenFilter"/>, <see cref="KeywordMarkerTokenFilter"/>, <see cref="LengthTokenFilter"/>, <see cref="LimitTokenFilter"/>, <see cref="NGramTokenFilter"/>, <see cref="NGramTokenFilterV2"/>, <see cref="PatternCaptureTokenFilter"/>, <see cref="PatternReplaceTokenFilter"/>, <see cref="PhoneticTokenFilter"/>, <see cref="ShingleTokenFilter"/>, <see cref="SnowballTokenFilter"/>, <see cref="StemmerOverrideTokenFilter"/>, <see cref="StemmerTokenFilter"/>, <see cref="StopwordsTokenFilter"/>, <see cref="SynonymTokenFilter"/>, <see cref="TruncateTokenFilter"/>, <see cref="UniqueTokenFilter"/> and <see cref="WordDelimiterTokenFilter"/>.
        /// </param>
        /// <param name="charFilters">
        /// The character filters for the index.
        /// Please note <see cref="CharFilter"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="MappingCharFilter"/> and <see cref="PatternReplaceCharFilter"/>.
        /// </param>
        /// <param name="encryptionKey"> A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your data when you want full assurance that no one, not even Microsoft, can decrypt your data in Azure Cognitive Search. Once you have encrypted your data, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your data will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. </param>
        /// <param name="similarity">
        /// The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used.
        /// Please note <see cref="Similarity"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BM25Similarity"/> and <see cref="ClassicSimilarity"/>.
        /// </param>
        /// <param name="eTag"> The ETag of the index. </param>
        /// <returns> A new <see cref="Models.Index"/> instance for mocking. </returns>
        public static Index Index(string name = null, IEnumerable<Field> fields = null, IEnumerable<ScoringProfile> scoringProfiles = null, string defaultScoringProfile = null, CorsOptions corsOptions = null, IEnumerable<Suggester> suggesters = null, IEnumerable<Analyzer> analyzers = null, IEnumerable<Tokenizer> tokenizers = null, IEnumerable<TokenFilter> tokenFilters = null, IEnumerable<CharFilter> charFilters = null, EncryptionKey encryptionKey = null, Similarity similarity = null, string eTag = null)
        {
            fields ??= new List<Field>();
            scoringProfiles ??= new List<ScoringProfile>();
            suggesters ??= new List<Suggester>();
            analyzers ??= new List<Analyzer>();
            tokenizers ??= new List<Tokenizer>();
            tokenFilters ??= new List<TokenFilter>();
            charFilters ??= new List<CharFilter>();

            return new Index(name, fields?.ToList(), scoringProfiles?.ToList(), defaultScoringProfile, corsOptions, suggesters?.ToList(), analyzers?.ToList(), tokenizers?.ToList(), tokenFilters?.ToList(), charFilters?.ToList(), encryptionKey, similarity, eTag);
        }

        /// <summary> Initializes a new instance of Field. </summary>
        /// <param name="name"> The name of the field, which must be unique within the fields collection of the index or parent field. </param>
        /// <param name="type"> The data type of the field. </param>
        /// <param name="key"> A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields. </param>
        /// <param name="retrievable"> A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields. </param>
        /// <param name="searchable"> A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like &quot;sunny day&quot;, internally it will be split into the individual tokens &quot;sunny&quot; and &quot;day&quot;. This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don&apos;t need a field to be included in searches, set searchable to false. </param>
        /// <param name="filterable"> A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to &quot;sunny day&quot;, $filter=f eq &apos;sunny&apos; will find no matches, but $filter=f eq &apos;sunny day&apos; will. This property must be null for complex fields. Default is true for simple fields and null for complex fields. </param>
        /// <param name="sortable"> A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it&apos;s an immediate parent field, or an ancestor field, that&apos;s the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields. </param>
        /// <param name="facetable"> A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields. </param>
        /// <param name="analyzer"> The name of the analyzer to use for the field. This option can be used only with searchable fields and it can&apos;t be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields. </param>
        /// <param name="searchAnalyzer"> The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields. </param>
        /// <param name="indexAnalyzer"> The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields. </param>
        /// <param name="synonymMaps"> A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields. </param>
        /// <param name="fields"> A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields. </param>
        /// <returns> A new <see cref="Models.Field"/> instance for mocking. </returns>
        public static Field Field(string name = null, DataType type = default, bool? key = null, bool? retrievable = null, bool? searchable = null, bool? filterable = null, bool? sortable = null, bool? facetable = null, AnalyzerName? analyzer = null, AnalyzerName? searchAnalyzer = null, AnalyzerName? indexAnalyzer = null, IEnumerable<string> synonymMaps = null, IEnumerable<Field> fields = null)
        {
            synonymMaps ??= new List<string>();
            fields ??= new List<Field>();

            return new Field(name, type, key, retrievable, searchable, filterable, sortable, facetable, analyzer, searchAnalyzer, indexAnalyzer, synonymMaps?.ToList(), fields?.ToList());
        }

        /// <summary> Initializes a new instance of ScoringProfile. </summary>
        /// <param name="name"> The name of the scoring profile. </param>
        /// <param name="textWeights"> Parameters that boost scoring based on text matches in certain index fields. </param>
        /// <param name="functions">
        /// The collection of functions that influence the scoring of documents.
        /// Please note <see cref="ScoringFunction"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="DistanceScoringFunction"/>, <see cref="FreshnessScoringFunction"/>, <see cref="MagnitudeScoringFunction"/> and <see cref="TagScoringFunction"/>.
        /// </param>
        /// <param name="functionAggregation"> A value indicating how the results of individual scoring functions should be combined. Defaults to &quot;Sum&quot;. Ignored if there are no scoring functions. </param>
        /// <returns> A new <see cref="Models.ScoringProfile"/> instance for mocking. </returns>
        public static ScoringProfile ScoringProfile(string name = null, TextWeights textWeights = null, IEnumerable<ScoringFunction> functions = null, ScoringFunctionAggregation? functionAggregation = null)
        {
            functions ??= new List<ScoringFunction>();

            return new ScoringProfile(name, textWeights, functions?.ToList(), functionAggregation);
        }

        /// <summary> Initializes a new instance of ScoringFunction. </summary>
        /// <param name="type"> Indicates the type of function to use. Valid values include magnitude, freshness, distance, and tag. The function type must be lower case. </param>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <returns> A new <see cref="Models.ScoringFunction"/> instance for mocking. </returns>
        public static ScoringFunction ScoringFunction(string type = null, string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null)
        {
            return new UnknownScoringFunction(type, fieldName, boost, interpolation);
        }

        /// <summary> Initializes a new instance of CorsOptions. </summary>
        /// <param name="allowedOrigins"> The list of origins from which JavaScript code will be granted access to your index. Can contain a list of hosts of the form {protocol}://{fully-qualified-domain-name}[:{port#}], or a single &apos;*&apos; to allow all origins (not recommended). </param>
        /// <param name="maxAgeInSeconds"> The duration for which browsers should cache CORS preflight responses. Defaults to 5 minutes. </param>
        /// <returns> A new <see cref="Models.CorsOptions"/> instance for mocking. </returns>
        public static CorsOptions CorsOptions(IEnumerable<string> allowedOrigins = null, long? maxAgeInSeconds = null)
        {
            allowedOrigins ??= new List<string>();

            return new CorsOptions(allowedOrigins?.ToList(), maxAgeInSeconds);
        }

        /// <summary> Initializes a new instance of Analyzer. </summary>
        /// <param name="odataType"> Identifies the concrete type of the analyzer. </param>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <returns> A new <see cref="Models.Analyzer"/> instance for mocking. </returns>
        public static Analyzer Analyzer(string odataType = null, string name = null)
        {
            return new UnknownAnalyzer(odataType, name);
        }

        /// <summary> Initializes a new instance of Tokenizer. </summary>
        /// <param name="odataType"> Identifies the concrete type of the tokenizer. </param>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <returns> A new <see cref="Models.Tokenizer"/> instance for mocking. </returns>
        public static Tokenizer Tokenizer(string odataType = null, string name = null)
        {
            return new UnknownTokenizer(odataType, name);
        }

        /// <summary> Initializes a new instance of TokenFilter. </summary>
        /// <param name="odataType"> Identifies the concrete type of the token filter. </param>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <returns> A new <see cref="Models.TokenFilter"/> instance for mocking. </returns>
        public static TokenFilter TokenFilter(string odataType = null, string name = null)
        {
            return new UnknownTokenFilter(odataType, name);
        }

        /// <summary> Initializes a new instance of CharFilter. </summary>
        /// <param name="odataType"> Identifies the concrete type of the char filter. </param>
        /// <param name="name"> The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <returns> A new <see cref="Models.CharFilter"/> instance for mocking. </returns>
        public static CharFilter CharFilter(string odataType = null, string name = null)
        {
            return new UnknownCharFilter(odataType, name);
        }

        /// <summary> Initializes a new instance of Similarity. </summary>
        /// <param name="odataType"></param>
        /// <returns> A new <see cref="Models.Similarity"/> instance for mocking. </returns>
        public static Similarity Similarity(string odataType = null)
        {
            return new UnknownSimilarity(odataType);
        }

        /// <summary> Initializes a new instance of ListIndexesResult. </summary>
        /// <param name="indexes"> The indexes in the Search service. </param>
        /// <returns> A new <see cref="Models.ListIndexesResult"/> instance for mocking. </returns>
        public static ListIndexesResult ListIndexesResult(IEnumerable<Index> indexes = null)
        {
            indexes ??= new List<Index>();

            return new ListIndexesResult(indexes?.ToList());
        }

        /// <summary> Initializes a new instance of GetIndexStatisticsResult. </summary>
        /// <param name="documentCount"> The number of documents in the index. </param>
        /// <param name="storageSize"> The amount of storage in bytes consumed by the index. </param>
        /// <returns> A new <see cref="Models.GetIndexStatisticsResult"/> instance for mocking. </returns>
        public static GetIndexStatisticsResult GetIndexStatisticsResult(long documentCount = default, long storageSize = default)
        {
            return new GetIndexStatisticsResult(documentCount, storageSize);
        }

        /// <summary> Initializes a new instance of AnalyzeResult. </summary>
        /// <param name="tokens"> The list of tokens returned by the analyzer specified in the request. </param>
        /// <returns> A new <see cref="Models.AnalyzeResult"/> instance for mocking. </returns>
        public static AnalyzeResult AnalyzeResult(IEnumerable<TokenInfo> tokens = null)
        {
            tokens ??= new List<TokenInfo>();

            return new AnalyzeResult(tokens?.ToList());
        }

        /// <summary> Initializes a new instance of TokenInfo. </summary>
        /// <param name="token"> The token returned by the analyzer. </param>
        /// <param name="startOffset"> The index of the first character of the token in the input text. </param>
        /// <param name="endOffset"> The index of the last character of the token in the input text. </param>
        /// <param name="position"> The position of the token in the input text relative to other tokens. The first token in the input text has position 0, the next has position 1, and so on. Depending on the analyzer used, some tokens might have the same position, for example if they are synonyms of each other. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="token"/> is null. </exception>
        /// <returns> A new <see cref="Models.TokenInfo"/> instance for mocking. </returns>
        public static TokenInfo TokenInfo(string token = null, int startOffset = default, int endOffset = default, int position = default)
        {
            if (token == null)
            {
                throw new ArgumentNullException(nameof(token));
            }

            return new TokenInfo(token, startOffset, endOffset, position);
        }

        /// <summary> Initializes a new instance of ServiceStatistics. </summary>
        /// <param name="counters"> Service level resource counters. </param>
        /// <param name="limits"> Service level general limits. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="counters"/> or <paramref name="limits"/> is null. </exception>
        /// <returns> A new <see cref="Models.ServiceStatistics"/> instance for mocking. </returns>
        public static ServiceStatistics ServiceStatistics(ServiceCounters counters = null, ServiceLimits limits = null)
        {
            if (counters == null)
            {
                throw new ArgumentNullException(nameof(counters));
            }
            if (limits == null)
            {
                throw new ArgumentNullException(nameof(limits));
            }

            return new ServiceStatistics(counters, limits);
        }

        /// <summary> Initializes a new instance of ServiceCounters. </summary>
        /// <param name="documentCounter"> Total number of documents across all indexes in the service. </param>
        /// <param name="indexCounter"> Total number of indexes. </param>
        /// <param name="indexerCounter"> Total number of indexers. </param>
        /// <param name="dataSourceCounter"> Total number of data sources. </param>
        /// <param name="storageSizeCounter"> Total size of used storage in bytes. </param>
        /// <param name="synonymMapCounter"> Total number of synonym maps. </param>
        /// <param name="skillsetCounter"> Total number of skillsets. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="documentCounter"/>, <paramref name="indexCounter"/>, <paramref name="indexerCounter"/>, <paramref name="dataSourceCounter"/>, <paramref name="storageSizeCounter"/>, <paramref name="synonymMapCounter"/> or <paramref name="skillsetCounter"/> is null. </exception>
        /// <returns> A new <see cref="Models.ServiceCounters"/> instance for mocking. </returns>
        public static ServiceCounters ServiceCounters(ResourceCounter documentCounter = null, ResourceCounter indexCounter = null, ResourceCounter indexerCounter = null, ResourceCounter dataSourceCounter = null, ResourceCounter storageSizeCounter = null, ResourceCounter synonymMapCounter = null, ResourceCounter skillsetCounter = null)
        {
            if (documentCounter == null)
            {
                throw new ArgumentNullException(nameof(documentCounter));
            }
            if (indexCounter == null)
            {
                throw new ArgumentNullException(nameof(indexCounter));
            }
            if (indexerCounter == null)
            {
                throw new ArgumentNullException(nameof(indexerCounter));
            }
            if (dataSourceCounter == null)
            {
                throw new ArgumentNullException(nameof(dataSourceCounter));
            }
            if (storageSizeCounter == null)
            {
                throw new ArgumentNullException(nameof(storageSizeCounter));
            }
            if (synonymMapCounter == null)
            {
                throw new ArgumentNullException(nameof(synonymMapCounter));
            }
            if (skillsetCounter == null)
            {
                throw new ArgumentNullException(nameof(skillsetCounter));
            }

            return new ServiceCounters(documentCounter, indexCounter, indexerCounter, dataSourceCounter, storageSizeCounter, synonymMapCounter, skillsetCounter);
        }

        /// <summary> Initializes a new instance of ResourceCounter. </summary>
        /// <param name="usage"> The resource usage amount. </param>
        /// <param name="quota"> The resource amount quota. </param>
        /// <returns> A new <see cref="Models.ResourceCounter"/> instance for mocking. </returns>
        public static ResourceCounter ResourceCounter(long usage = default, long? quota = null)
        {
            return new ResourceCounter(usage, quota);
        }

        /// <summary> Initializes a new instance of ServiceLimits. </summary>
        /// <param name="maxFieldsPerIndex"> The maximum allowed fields per index. </param>
        /// <param name="maxFieldNestingDepthPerIndex"> The maximum depth which you can nest sub-fields in an index, including the top-level complex field. For example, a/b/c has a nesting depth of 3. </param>
        /// <param name="maxComplexCollectionFieldsPerIndex"> The maximum number of fields of type Collection(Edm.ComplexType) allowed in an index. </param>
        /// <param name="maxComplexObjectsInCollectionsPerDocument"> The maximum number of objects in complex collections allowed per document. </param>
        /// <returns> A new <see cref="Models.ServiceLimits"/> instance for mocking. </returns>
        public static ServiceLimits ServiceLimits(int? maxFieldsPerIndex = null, int? maxFieldNestingDepthPerIndex = null, int? maxComplexCollectionFieldsPerIndex = null, int? maxComplexObjectsInCollectionsPerDocument = null)
        {
            return new ServiceLimits(maxFieldsPerIndex, maxFieldNestingDepthPerIndex, maxComplexCollectionFieldsPerIndex, maxComplexObjectsInCollectionsPerDocument);
        }

        /// <summary> Initializes a new instance of CustomAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="tokenizer"> The name of the tokenizer to use to divide continuous text into a sequence of tokens, such as breaking a sentence into words. </param>
        /// <param name="tokenFilters"> A list of token filters used to filter out or modify the tokens generated by a tokenizer. For example, you can specify a lowercase filter that converts all characters to lowercase. The filters are run in the order in which they are listed. </param>
        /// <param name="charFilters"> A list of character filters used to prepare input text before it is processed by the tokenizer. For instance, they can replace certain characters or symbols. The filters are run in the order in which they are listed. </param>
        /// <returns> A new <see cref="Models.CustomAnalyzer"/> instance for mocking. </returns>
        public static CustomAnalyzer CustomAnalyzer(string name = null, TokenizerName tokenizer = default, IEnumerable<TokenFilterName> tokenFilters = null, IEnumerable<CharFilterName> charFilters = null)
        {
            tokenFilters ??= new List<TokenFilterName>();
            charFilters ??= new List<CharFilterName>();

            return new CustomAnalyzer("#Microsoft.Azure.Search.CustomAnalyzer", name, tokenizer, tokenFilters?.ToList(), charFilters?.ToList());
        }

        /// <summary> Initializes a new instance of PatternAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="lowerCaseTerms"> A value indicating whether terms should be lower-cased. Default is true. </param>
        /// <param name="pattern"> A regular expression pattern to match token separators. Default is an expression that matches one or more whitespace characters. </param>
        /// <param name="flags"> Regular expression flags. </param>
        /// <param name="stopwords"> A list of stopwords. </param>
        /// <returns> A new <see cref="Models.PatternAnalyzer"/> instance for mocking. </returns>
        public static PatternAnalyzer PatternAnalyzer(string name = null, bool? lowerCaseTerms = null, string pattern = null, RegexFlags? flags = null, IEnumerable<string> stopwords = null)
        {
            stopwords ??= new List<string>();

            return new PatternAnalyzer("#Microsoft.Azure.Search.PatternAnalyzer", name, lowerCaseTerms, pattern, flags, stopwords?.ToList());
        }

        /// <summary> Initializes a new instance of StandardAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <param name="stopwords"> A list of stopwords. </param>
        /// <returns> A new <see cref="Models.StandardAnalyzer"/> instance for mocking. </returns>
        public static StandardAnalyzer StandardAnalyzer(string name = null, int? maxTokenLength = null, IEnumerable<string> stopwords = null)
        {
            stopwords ??= new List<string>();

            return new StandardAnalyzer("#Microsoft.Azure.Search.StandardAnalyzer", name, maxTokenLength, stopwords?.ToList());
        }

        /// <summary> Initializes a new instance of StopAnalyzer. </summary>
        /// <param name="name"> The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="stopwords"> A list of stopwords. </param>
        /// <returns> A new <see cref="Models.StopAnalyzer"/> instance for mocking. </returns>
        public static StopAnalyzer StopAnalyzer(string name = null, IEnumerable<string> stopwords = null)
        {
            stopwords ??= new List<string>();

            return new StopAnalyzer("#Microsoft.Azure.Search.StopAnalyzer", name, stopwords?.ToList());
        }

        /// <summary> Initializes a new instance of ClassicTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Models.ClassicTokenizer"/> instance for mocking. </returns>
        public static ClassicTokenizer ClassicTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new ClassicTokenizer("#Microsoft.Azure.Search.ClassicTokenizer", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of EdgeNGramTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <param name="tokenChars"> Character classes to keep in the tokens. </param>
        /// <returns> A new <see cref="Models.EdgeNGramTokenizer"/> instance for mocking. </returns>
        public static EdgeNGramTokenizer EdgeNGramTokenizer(string name = null, int? minGram = null, int? maxGram = null, IEnumerable<TokenCharacterKind> tokenChars = null)
        {
            tokenChars ??= new List<TokenCharacterKind>();

            return new EdgeNGramTokenizer("#Microsoft.Azure.Search.EdgeNGramTokenizer", name, minGram, maxGram, tokenChars?.ToList());
        }

        /// <summary> Initializes a new instance of KeywordTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="bufferSize"> The read buffer size in bytes. Default is 256. </param>
        /// <returns> A new <see cref="Models.KeywordTokenizer"/> instance for mocking. </returns>
        public static KeywordTokenizer KeywordTokenizer(string name = null, int? bufferSize = null)
        {
            return new KeywordTokenizer("#Microsoft.Azure.Search.KeywordTokenizer", name, bufferSize);
        }

        /// <summary> Initializes a new instance of KeywordTokenizerV2. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 256. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Models.KeywordTokenizerV2"/> instance for mocking. </returns>
        public static KeywordTokenizerV2 KeywordTokenizerV2(string name = null, int? maxTokenLength = null)
        {
            return new KeywordTokenizerV2("#Microsoft.Azure.Search.KeywordTokenizerV2", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of MicrosoftLanguageTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Tokens longer than the maximum length are split. Maximum token length that can be used is 300 characters. Tokens longer than 300 characters are first split into tokens of length 300 and then each of those tokens is split based on the max token length set. Default is 255. </param>
        /// <param name="isSearchTokenizer"> A value indicating how the tokenizer is used. Set to true if used as the search tokenizer, set to false if used as the indexing tokenizer. Default is false. </param>
        /// <param name="language"> The language to use. The default is English. </param>
        /// <returns> A new <see cref="Models.MicrosoftLanguageTokenizer"/> instance for mocking. </returns>
        public static MicrosoftLanguageTokenizer MicrosoftLanguageTokenizer(string name = null, int? maxTokenLength = null, bool? isSearchTokenizer = null, MicrosoftTokenizerLanguage? language = null)
        {
            return new MicrosoftLanguageTokenizer("#Microsoft.Azure.Search.MicrosoftLanguageTokenizer", name, maxTokenLength, isSearchTokenizer, language);
        }

        /// <summary> Initializes a new instance of MicrosoftLanguageStemmingTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Tokens longer than the maximum length are split. Maximum token length that can be used is 300 characters. Tokens longer than 300 characters are first split into tokens of length 300 and then each of those tokens is split based on the max token length set. Default is 255. </param>
        /// <param name="isSearchTokenizer"> A value indicating how the tokenizer is used. Set to true if used as the search tokenizer, set to false if used as the indexing tokenizer. Default is false. </param>
        /// <param name="language"> The language to use. The default is English. </param>
        /// <returns> A new <see cref="Models.MicrosoftLanguageStemmingTokenizer"/> instance for mocking. </returns>
        public static MicrosoftLanguageStemmingTokenizer MicrosoftLanguageStemmingTokenizer(string name = null, int? maxTokenLength = null, bool? isSearchTokenizer = null, MicrosoftStemmingTokenizerLanguage? language = null)
        {
            return new MicrosoftLanguageStemmingTokenizer("#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer", name, maxTokenLength, isSearchTokenizer, language);
        }

        /// <summary> Initializes a new instance of NGramTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <param name="tokenChars"> Character classes to keep in the tokens. </param>
        /// <returns> A new <see cref="Models.NGramTokenizer"/> instance for mocking. </returns>
        public static NGramTokenizer NGramTokenizer(string name = null, int? minGram = null, int? maxGram = null, IEnumerable<TokenCharacterKind> tokenChars = null)
        {
            tokenChars ??= new List<TokenCharacterKind>();

            return new NGramTokenizer("#Microsoft.Azure.Search.NGramTokenizer", name, minGram, maxGram, tokenChars?.ToList());
        }

        /// <summary> Initializes a new instance of PathHierarchyTokenizerV2. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="delimiter"> The delimiter character to use. Default is &quot;/&quot;. </param>
        /// <param name="replacement"> A value that, if set, replaces the delimiter character. Default is &quot;/&quot;. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default and maximum is 300. </param>
        /// <param name="reverseTokenOrder"> A value indicating whether to generate tokens in reverse order. Default is false. </param>
        /// <param name="numberOfTokensToSkip"> The number of initial tokens to skip. Default is 0. </param>
        /// <returns> A new <see cref="Models.PathHierarchyTokenizerV2"/> instance for mocking. </returns>
        public static PathHierarchyTokenizerV2 PathHierarchyTokenizerV2(string name = null, char? delimiter = null, char? replacement = null, int? maxTokenLength = null, bool? reverseTokenOrder = null, int? numberOfTokensToSkip = null)
        {
            return new PathHierarchyTokenizerV2("#Microsoft.Azure.Search.PathHierarchyTokenizerV2", name, delimiter, replacement, maxTokenLength, reverseTokenOrder, numberOfTokensToSkip);
        }

        /// <summary> Initializes a new instance of PatternTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="pattern"> A regular expression pattern to match token separators. Default is an expression that matches one or more whitespace characters. </param>
        /// <param name="flags"> Regular expression flags. </param>
        /// <param name="group"> The zero-based ordinal of the matching group in the regular expression pattern to extract into tokens. Use -1 if you want to use the entire pattern to split the input into tokens, irrespective of matching groups. Default is -1. </param>
        /// <returns> A new <see cref="Models.PatternTokenizer"/> instance for mocking. </returns>
        public static PatternTokenizer PatternTokenizer(string name = null, string pattern = null, RegexFlags? flags = null, int? group = null)
        {
            return new PatternTokenizer("#Microsoft.Azure.Search.PatternTokenizer", name, pattern, flags, group);
        }

        /// <summary> Initializes a new instance of StandardTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. </param>
        /// <returns> A new <see cref="Models.StandardTokenizer"/> instance for mocking. </returns>
        public static StandardTokenizer StandardTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new StandardTokenizer("#Microsoft.Azure.Search.StandardTokenizer", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of StandardTokenizerV2. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Models.StandardTokenizerV2"/> instance for mocking. </returns>
        public static StandardTokenizerV2 StandardTokenizerV2(string name = null, int? maxTokenLength = null)
        {
            return new StandardTokenizerV2("#Microsoft.Azure.Search.StandardTokenizerV2", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of UaxUrlEmailTokenizer. </summary>
        /// <param name="name"> The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenLength"> The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. </param>
        /// <returns> A new <see cref="Models.UaxUrlEmailTokenizer"/> instance for mocking. </returns>
        public static UaxUrlEmailTokenizer UaxUrlEmailTokenizer(string name = null, int? maxTokenLength = null)
        {
            return new UaxUrlEmailTokenizer("#Microsoft.Azure.Search.UaxUrlEmailTokenizer", name, maxTokenLength);
        }

        /// <summary> Initializes a new instance of AsciiFoldingTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="preserveOriginal"> A value indicating whether the original token will be kept. Default is false. </param>
        /// <returns> A new <see cref="Models.AsciiFoldingTokenFilter"/> instance for mocking. </returns>
        public static AsciiFoldingTokenFilter AsciiFoldingTokenFilter(string name = null, bool? preserveOriginal = null)
        {
            return new AsciiFoldingTokenFilter("#Microsoft.Azure.Search.AsciiFoldingTokenFilter", name, preserveOriginal);
        }

        /// <summary> Initializes a new instance of CjkBigramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="ignoreScripts"> The scripts to ignore. </param>
        /// <param name="outputUnigrams"> A value indicating whether to output both unigrams and bigrams (if true), or just bigrams (if false). Default is false. </param>
        /// <returns> A new <see cref="Models.CjkBigramTokenFilter"/> instance for mocking. </returns>
        public static CjkBigramTokenFilter CjkBigramTokenFilter(string name = null, IEnumerable<CjkBigramTokenFilterScripts> ignoreScripts = null, bool? outputUnigrams = null)
        {
            ignoreScripts ??= new List<CjkBigramTokenFilterScripts>();

            return new CjkBigramTokenFilter("#Microsoft.Azure.Search.CjkBigramTokenFilter", name, ignoreScripts?.ToList(), outputUnigrams);
        }

        /// <summary> Initializes a new instance of CommonGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="commonWords"> The set of common words. </param>
        /// <param name="ignoreCase"> A value indicating whether common words matching will be case insensitive. Default is false. </param>
        /// <param name="useQueryMode"> A value that indicates whether the token filter is in query mode. When in query mode, the token filter generates bigrams and then removes common words and single terms followed by a common word. Default is false. </param>
        /// <returns> A new <see cref="Models.CommonGramTokenFilter"/> instance for mocking. </returns>
        public static CommonGramTokenFilter CommonGramTokenFilter(string name = null, IEnumerable<string> commonWords = null, bool? ignoreCase = null, bool? useQueryMode = null)
        {
            commonWords ??= new List<string>();

            return new CommonGramTokenFilter("#Microsoft.Azure.Search.CommonGramTokenFilter", name, commonWords?.ToList(), ignoreCase, useQueryMode);
        }

        /// <summary> Initializes a new instance of DictionaryDecompounderTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="wordList"> The list of words to match against. </param>
        /// <param name="minWordSize"> The minimum word size. Only words longer than this get processed. Default is 5. Maximum is 300. </param>
        /// <param name="minSubwordSize"> The minimum subword size. Only subwords longer than this are outputted. Default is 2. Maximum is 300. </param>
        /// <param name="maxSubwordSize"> The maximum subword size. Only subwords shorter than this are outputted. Default is 15. Maximum is 300. </param>
        /// <param name="onlyLongestMatch"> A value indicating whether to add only the longest matching subword to the output. Default is false. </param>
        /// <returns> A new <see cref="Models.DictionaryDecompounderTokenFilter"/> instance for mocking. </returns>
        public static DictionaryDecompounderTokenFilter DictionaryDecompounderTokenFilter(string name = null, IEnumerable<string> wordList = null, int? minWordSize = null, int? minSubwordSize = null, int? maxSubwordSize = null, bool? onlyLongestMatch = null)
        {
            wordList ??= new List<string>();

            return new DictionaryDecompounderTokenFilter("#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter", name, wordList?.ToList(), minWordSize, minSubwordSize, maxSubwordSize, onlyLongestMatch);
        }

        /// <summary> Initializes a new instance of EdgeNGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. </param>
        /// <param name="side"> Specifies which side of the input the n-gram should be generated from. Default is &quot;front&quot;. </param>
        /// <returns> A new <see cref="Models.EdgeNGramTokenFilter"/> instance for mocking. </returns>
        public static EdgeNGramTokenFilter EdgeNGramTokenFilter(string name = null, int? minGram = null, int? maxGram = null, EdgeNGramTokenFilterSide? side = null)
        {
            return new EdgeNGramTokenFilter("#Microsoft.Azure.Search.EdgeNGramTokenFilter", name, minGram, maxGram, side);
        }

        /// <summary> Initializes a new instance of EdgeNGramTokenFilterV2. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <param name="side"> Specifies which side of the input the n-gram should be generated from. Default is &quot;front&quot;. </param>
        /// <returns> A new <see cref="Models.EdgeNGramTokenFilterV2"/> instance for mocking. </returns>
        public static EdgeNGramTokenFilterV2 EdgeNGramTokenFilterV2(string name = null, int? minGram = null, int? maxGram = null, EdgeNGramTokenFilterSide? side = null)
        {
            return new EdgeNGramTokenFilterV2("#Microsoft.Azure.Search.EdgeNGramTokenFilterV2", name, minGram, maxGram, side);
        }

        /// <summary> Initializes a new instance of ElisionTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="articles"> The set of articles to remove. </param>
        /// <returns> A new <see cref="Models.ElisionTokenFilter"/> instance for mocking. </returns>
        public static ElisionTokenFilter ElisionTokenFilter(string name = null, IEnumerable<string> articles = null)
        {
            articles ??= new List<string>();

            return new ElisionTokenFilter("#Microsoft.Azure.Search.ElisionTokenFilter", name, articles?.ToList());
        }

        /// <summary> Initializes a new instance of KeepTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="keepWords"> The list of words to keep. </param>
        /// <param name="lowerCaseKeepWords"> A value indicating whether to lower case all words first. Default is false. </param>
        /// <returns> A new <see cref="Models.KeepTokenFilter"/> instance for mocking. </returns>
        public static KeepTokenFilter KeepTokenFilter(string name = null, IEnumerable<string> keepWords = null, bool? lowerCaseKeepWords = null)
        {
            keepWords ??= new List<string>();

            return new KeepTokenFilter("#Microsoft.Azure.Search.KeepTokenFilter", name, keepWords?.ToList(), lowerCaseKeepWords);
        }

        /// <summary> Initializes a new instance of KeywordMarkerTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="keywords"> A list of words to mark as keywords. </param>
        /// <param name="ignoreCase"> A value indicating whether to ignore case. If true, all words are converted to lower case first. Default is false. </param>
        /// <returns> A new <see cref="Models.KeywordMarkerTokenFilter"/> instance for mocking. </returns>
        public static KeywordMarkerTokenFilter KeywordMarkerTokenFilter(string name = null, IEnumerable<string> keywords = null, bool? ignoreCase = null)
        {
            keywords ??= new List<string>();

            return new KeywordMarkerTokenFilter("#Microsoft.Azure.Search.KeywordMarkerTokenFilter", name, keywords?.ToList(), ignoreCase);
        }

        /// <summary> Initializes a new instance of LengthTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="min"> The minimum length in characters. Default is 0. Maximum is 300. Must be less than the value of max. </param>
        /// <param name="max"> The maximum length in characters. Default and maximum is 300. </param>
        /// <returns> A new <see cref="Models.LengthTokenFilter"/> instance for mocking. </returns>
        public static LengthTokenFilter LengthTokenFilter(string name = null, int? min = null, int? max = null)
        {
            return new LengthTokenFilter("#Microsoft.Azure.Search.LengthTokenFilter", name, min, max);
        }

        /// <summary> Initializes a new instance of LimitTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxTokenCount"> The maximum number of tokens to produce. Default is 1. </param>
        /// <param name="consumeAllTokens"> A value indicating whether all tokens from the input must be consumed even if maxTokenCount is reached. Default is false. </param>
        /// <returns> A new <see cref="Models.LimitTokenFilter"/> instance for mocking. </returns>
        public static LimitTokenFilter LimitTokenFilter(string name = null, int? maxTokenCount = null, bool? consumeAllTokens = null)
        {
            return new LimitTokenFilter("#Microsoft.Azure.Search.LimitTokenFilter", name, maxTokenCount, consumeAllTokens);
        }

        /// <summary> Initializes a new instance of NGramTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. </param>
        /// <returns> A new <see cref="Models.NGramTokenFilter"/> instance for mocking. </returns>
        public static NGramTokenFilter NGramTokenFilter(string name = null, int? minGram = null, int? maxGram = null)
        {
            return new NGramTokenFilter("#Microsoft.Azure.Search.NGramTokenFilter", name, minGram, maxGram);
        }

        /// <summary> Initializes a new instance of NGramTokenFilterV2. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="minGram"> The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. </param>
        /// <param name="maxGram"> The maximum n-gram length. Default is 2. Maximum is 300. </param>
        /// <returns> A new <see cref="Models.NGramTokenFilterV2"/> instance for mocking. </returns>
        public static NGramTokenFilterV2 NGramTokenFilterV2(string name = null, int? minGram = null, int? maxGram = null)
        {
            return new NGramTokenFilterV2("#Microsoft.Azure.Search.NGramTokenFilterV2", name, minGram, maxGram);
        }

        /// <summary> Initializes a new instance of PatternCaptureTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="patterns"> A list of patterns to match against each token. </param>
        /// <param name="preserveOriginal"> A value indicating whether to return the original token even if one of the patterns matches. Default is true. </param>
        /// <returns> A new <see cref="Models.PatternCaptureTokenFilter"/> instance for mocking. </returns>
        public static PatternCaptureTokenFilter PatternCaptureTokenFilter(string name = null, IEnumerable<string> patterns = null, bool? preserveOriginal = null)
        {
            patterns ??= new List<string>();

            return new PatternCaptureTokenFilter("#Microsoft.Azure.Search.PatternCaptureTokenFilter", name, patterns?.ToList(), preserveOriginal);
        }

        /// <summary> Initializes a new instance of PatternReplaceTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="pattern"> A regular expression pattern. </param>
        /// <param name="replacement"> The replacement text. </param>
        /// <returns> A new <see cref="Models.PatternReplaceTokenFilter"/> instance for mocking. </returns>
        public static PatternReplaceTokenFilter PatternReplaceTokenFilter(string name = null, string pattern = null, string replacement = null)
        {
            return new PatternReplaceTokenFilter("#Microsoft.Azure.Search.PatternReplaceTokenFilter", name, pattern, replacement);
        }

        /// <summary> Initializes a new instance of PhoneticTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="encoder"> The phonetic encoder to use. Default is &quot;metaphone&quot;. </param>
        /// <param name="replaceOriginalTokens"> A value indicating whether encoded tokens should replace original tokens. If false, encoded tokens are added as synonyms. Default is true. </param>
        /// <returns> A new <see cref="Models.PhoneticTokenFilter"/> instance for mocking. </returns>
        public static PhoneticTokenFilter PhoneticTokenFilter(string name = null, PhoneticEncoder? encoder = null, bool? replaceOriginalTokens = null)
        {
            return new PhoneticTokenFilter("#Microsoft.Azure.Search.PhoneticTokenFilter", name, encoder, replaceOriginalTokens);
        }

        /// <summary> Initializes a new instance of ShingleTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="maxShingleSize"> The maximum shingle size. Default and minimum value is 2. </param>
        /// <param name="minShingleSize"> The minimum shingle size. Default and minimum value is 2. Must be less than the value of maxShingleSize. </param>
        /// <param name="outputUnigrams"> A value indicating whether the output stream will contain the input tokens (unigrams) as well as shingles. Default is true. </param>
        /// <param name="outputUnigramsIfNoShingles"> A value indicating whether to output unigrams for those times when no shingles are available. This property takes precedence when outputUnigrams is set to false. Default is false. </param>
        /// <param name="tokenSeparator"> The string to use when joining adjacent tokens to form a shingle. Default is a single space (&quot; &quot;). </param>
        /// <param name="filterToken"> The string to insert for each position at which there is no token. Default is an underscore (&quot;_&quot;). </param>
        /// <returns> A new <see cref="Models.ShingleTokenFilter"/> instance for mocking. </returns>
        public static ShingleTokenFilter ShingleTokenFilter(string name = null, int? maxShingleSize = null, int? minShingleSize = null, bool? outputUnigrams = null, bool? outputUnigramsIfNoShingles = null, string tokenSeparator = null, string filterToken = null)
        {
            return new ShingleTokenFilter("#Microsoft.Azure.Search.ShingleTokenFilter", name, maxShingleSize, minShingleSize, outputUnigrams, outputUnigramsIfNoShingles, tokenSeparator, filterToken);
        }

        /// <summary> Initializes a new instance of SnowballTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="language"> The language to use. </param>
        /// <returns> A new <see cref="Models.SnowballTokenFilter"/> instance for mocking. </returns>
        public static SnowballTokenFilter SnowballTokenFilter(string name = null, SnowballTokenFilterLanguage language = default)
        {
            return new SnowballTokenFilter("#Microsoft.Azure.Search.SnowballTokenFilter", name, language);
        }

        /// <summary> Initializes a new instance of StemmerTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="language"> The language to use. </param>
        /// <returns> A new <see cref="Models.StemmerTokenFilter"/> instance for mocking. </returns>
        public static StemmerTokenFilter StemmerTokenFilter(string name = null, StemmerTokenFilterLanguage language = default)
        {
            return new StemmerTokenFilter("#Microsoft.Azure.Search.StemmerTokenFilter", name, language);
        }

        /// <summary> Initializes a new instance of StemmerOverrideTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="rules"> A list of stemming rules in the following format: &quot;word =&gt; stem&quot;, for example: &quot;ran =&gt; run&quot;. </param>
        /// <returns> A new <see cref="Models.StemmerOverrideTokenFilter"/> instance for mocking. </returns>
        public static StemmerOverrideTokenFilter StemmerOverrideTokenFilter(string name = null, IEnumerable<string> rules = null)
        {
            rules ??= new List<string>();

            return new StemmerOverrideTokenFilter("#Microsoft.Azure.Search.StemmerOverrideTokenFilter", name, rules?.ToList());
        }

        /// <summary> Initializes a new instance of StopwordsTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="stopwords"> The list of stopwords. This property and the stopwords list property cannot both be set. </param>
        /// <param name="stopwordsList"> A predefined list of stopwords to use. This property and the stopwords property cannot both be set. Default is English. </param>
        /// <param name="ignoreCase"> A value indicating whether to ignore case. If true, all words are converted to lower case first. Default is false. </param>
        /// <param name="removeTrailingStopWords"> A value indicating whether to ignore the last search term if it&apos;s a stop word. Default is true. </param>
        /// <returns> A new <see cref="Models.StopwordsTokenFilter"/> instance for mocking. </returns>
        public static StopwordsTokenFilter StopwordsTokenFilter(string name = null, IEnumerable<string> stopwords = null, StopwordsList? stopwordsList = null, bool? ignoreCase = null, bool? removeTrailingStopWords = null)
        {
            stopwords ??= new List<string>();

            return new StopwordsTokenFilter("#Microsoft.Azure.Search.StopwordsTokenFilter", name, stopwords?.ToList(), stopwordsList, ignoreCase, removeTrailingStopWords);
        }

        /// <summary> Initializes a new instance of SynonymTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="synonyms"> A list of synonyms in following one of two formats: 1. incredible, unbelievable, fabulous =&gt; amazing - all terms on the left side of =&gt; symbol will be replaced with all terms on its right side; 2. incredible, unbelievable, fabulous, amazing - comma separated list of equivalent words. Set the expand option to change how this list is interpreted. </param>
        /// <param name="ignoreCase"> A value indicating whether to case-fold input for matching. Default is false. </param>
        /// <param name="expand"> A value indicating whether all words in the list of synonyms (if =&gt; notation is not used) will map to one another. If true, all words in the list of synonyms (if =&gt; notation is not used) will map to one another. The following list: incredible, unbelievable, fabulous, amazing is equivalent to: incredible, unbelievable, fabulous, amazing =&gt; incredible, unbelievable, fabulous, amazing. If false, the following list: incredible, unbelievable, fabulous, amazing will be equivalent to: incredible, unbelievable, fabulous, amazing =&gt; incredible. Default is true. </param>
        /// <returns> A new <see cref="Models.SynonymTokenFilter"/> instance for mocking. </returns>
        public static SynonymTokenFilter SynonymTokenFilter(string name = null, IEnumerable<string> synonyms = null, bool? ignoreCase = null, bool? expand = null)
        {
            synonyms ??= new List<string>();

            return new SynonymTokenFilter("#Microsoft.Azure.Search.SynonymTokenFilter", name, synonyms?.ToList(), ignoreCase, expand);
        }

        /// <summary> Initializes a new instance of TruncateTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="length"> The length at which terms will be truncated. Default and maximum is 300. </param>
        /// <returns> A new <see cref="Models.TruncateTokenFilter"/> instance for mocking. </returns>
        public static TruncateTokenFilter TruncateTokenFilter(string name = null, int? length = null)
        {
            return new TruncateTokenFilter("#Microsoft.Azure.Search.TruncateTokenFilter", name, length);
        }

        /// <summary> Initializes a new instance of UniqueTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="onlyOnSamePosition"> A value indicating whether to remove duplicates only at the same position. Default is false. </param>
        /// <returns> A new <see cref="Models.UniqueTokenFilter"/> instance for mocking. </returns>
        public static UniqueTokenFilter UniqueTokenFilter(string name = null, bool? onlyOnSamePosition = null)
        {
            return new UniqueTokenFilter("#Microsoft.Azure.Search.UniqueTokenFilter", name, onlyOnSamePosition);
        }

        /// <summary> Initializes a new instance of WordDelimiterTokenFilter. </summary>
        /// <param name="name"> The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="generateWordParts"> A value indicating whether to generate part words. If set, causes parts of words to be generated; for example &quot;AzureSearch&quot; becomes &quot;Azure&quot; &quot;Search&quot;. Default is true. </param>
        /// <param name="generateNumberParts"> A value indicating whether to generate number subwords. Default is true. </param>
        /// <param name="catenateWords"> A value indicating whether maximum runs of word parts will be catenated. For example, if this is set to true, &quot;Azure-Search&quot; becomes &quot;AzureSearch&quot;. Default is false. </param>
        /// <param name="catenateNumbers"> A value indicating whether maximum runs of number parts will be catenated. For example, if this is set to true, &quot;1-2&quot; becomes &quot;12&quot;. Default is false. </param>
        /// <param name="catenateAll"> A value indicating whether all subword parts will be catenated. For example, if this is set to true, &quot;Azure-Search-1&quot; becomes &quot;AzureSearch1&quot;. Default is false. </param>
        /// <param name="splitOnCaseChange"> A value indicating whether to split words on caseChange. For example, if this is set to true, &quot;AzureSearch&quot; becomes &quot;Azure&quot; &quot;Search&quot;. Default is true. </param>
        /// <param name="preserveOriginal"> A value indicating whether original words will be preserved and added to the subword list. Default is false. </param>
        /// <param name="splitOnNumerics"> A value indicating whether to split on numbers. For example, if this is set to true, &quot;Azure1Search&quot; becomes &quot;Azure&quot; &quot;1&quot; &quot;Search&quot;. Default is true. </param>
        /// <param name="stemEnglishPossessive"> A value indicating whether to remove trailing &quot;&apos;s&quot; for each subword. Default is true. </param>
        /// <param name="protectedWords"> A list of tokens to protect from being delimited. </param>
        /// <returns> A new <see cref="Models.WordDelimiterTokenFilter"/> instance for mocking. </returns>
        public static WordDelimiterTokenFilter WordDelimiterTokenFilter(string name = null, bool? generateWordParts = null, bool? generateNumberParts = null, bool? catenateWords = null, bool? catenateNumbers = null, bool? catenateAll = null, bool? splitOnCaseChange = null, bool? preserveOriginal = null, bool? splitOnNumerics = null, bool? stemEnglishPossessive = null, IEnumerable<string> protectedWords = null)
        {
            protectedWords ??= new List<string>();

            return new WordDelimiterTokenFilter("#Microsoft.Azure.Search.WordDelimiterTokenFilter", name, generateWordParts, generateNumberParts, catenateWords, catenateNumbers, catenateAll, splitOnCaseChange, preserveOriginal, splitOnNumerics, stemEnglishPossessive, protectedWords?.ToList());
        }

        /// <summary> Initializes a new instance of MappingCharFilter. </summary>
        /// <param name="name"> The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="mappings"> A list of mappings of the following format: &quot;a=&gt;b&quot; (all occurrences of the character &quot;a&quot; will be replaced with character &quot;b&quot;). </param>
        /// <returns> A new <see cref="Models.MappingCharFilter"/> instance for mocking. </returns>
        public static MappingCharFilter MappingCharFilter(string name = null, IEnumerable<string> mappings = null)
        {
            mappings ??= new List<string>();

            return new MappingCharFilter("#Microsoft.Azure.Search.MappingCharFilter", name, mappings?.ToList());
        }

        /// <summary> Initializes a new instance of PatternReplaceCharFilter. </summary>
        /// <param name="name"> The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. </param>
        /// <param name="pattern"> A regular expression pattern. </param>
        /// <param name="replacement"> The replacement text. </param>
        /// <returns> A new <see cref="Models.PatternReplaceCharFilter"/> instance for mocking. </returns>
        public static PatternReplaceCharFilter PatternReplaceCharFilter(string name = null, string pattern = null, string replacement = null)
        {
            return new PatternReplaceCharFilter("#Microsoft.Azure.Search.PatternReplaceCharFilter", name, pattern, replacement);
        }

        /// <summary> Initializes a new instance of ClassicSimilarity. </summary>
        /// <returns> A new <see cref="Models.ClassicSimilarity"/> instance for mocking. </returns>
        public static ClassicSimilarity ClassicSimilarity()
        {
            return new ClassicSimilarity("#Microsoft.Azure.Search.ClassicSimilarity");
        }

        /// <summary> Initializes a new instance of BM25Similarity. </summary>
        /// <param name="k1"> This property controls the scaling function between the term frequency of each matching terms and the final relevance score of a document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the score does not scale with an increase in term frequency. </param>
        /// <param name="b"> This property controls how the length of a document affects the relevance score. By default, a value of 0.75 is used. A value of 0.0 means no length normalization is applied, while a value of 1.0 means the score is fully normalized by the length of the document. </param>
        /// <returns> A new <see cref="Models.BM25Similarity"/> instance for mocking. </returns>
        public static BM25Similarity BM25Similarity(double? k1 = null, double? b = null)
        {
            return new BM25Similarity("#Microsoft.Azure.Search.BM25Similarity", k1, b);
        }

        /// <summary> Initializes a new instance of HighWaterMarkChangeDetectionPolicy. </summary>
        /// <param name="highWaterMarkColumnName"> The name of the high water mark column. </param>
        /// <returns> A new <see cref="Models.HighWaterMarkChangeDetectionPolicy"/> instance for mocking. </returns>
        public static HighWaterMarkChangeDetectionPolicy HighWaterMarkChangeDetectionPolicy(string highWaterMarkColumnName = null)
        {
            return new HighWaterMarkChangeDetectionPolicy("#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy", highWaterMarkColumnName);
        }

        /// <summary> Initializes a new instance of SqlIntegratedChangeTrackingPolicy. </summary>
        /// <returns> A new <see cref="Models.SqlIntegratedChangeTrackingPolicy"/> instance for mocking. </returns>
        public static SqlIntegratedChangeTrackingPolicy SqlIntegratedChangeTrackingPolicy()
        {
            return new SqlIntegratedChangeTrackingPolicy("#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy");
        }

        /// <summary> Initializes a new instance of SoftDeleteColumnDeletionDetectionPolicy. </summary>
        /// <param name="softDeleteColumnName"> The name of the column to use for soft-deletion detection. </param>
        /// <param name="softDeleteMarkerValue"> The marker value that identifies an item as deleted. </param>
        /// <returns> A new <see cref="Models.SoftDeleteColumnDeletionDetectionPolicy"/> instance for mocking. </returns>
        public static SoftDeleteColumnDeletionDetectionPolicy SoftDeleteColumnDeletionDetectionPolicy(string softDeleteColumnName = null, string softDeleteMarkerValue = null)
        {
            return new SoftDeleteColumnDeletionDetectionPolicy("#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy", softDeleteColumnName, softDeleteMarkerValue);
        }

        /// <summary> Initializes a new instance of DistanceScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the distance scoring function. </param>
        /// <returns> A new <see cref="Models.DistanceScoringFunction"/> instance for mocking. </returns>
        public static DistanceScoringFunction DistanceScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, DistanceScoringParameters parameters = null)
        {
            return new DistanceScoringFunction("distance", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of FreshnessScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the freshness scoring function. </param>
        /// <returns> A new <see cref="Models.FreshnessScoringFunction"/> instance for mocking. </returns>
        public static FreshnessScoringFunction FreshnessScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, FreshnessScoringParameters parameters = null)
        {
            return new FreshnessScoringFunction("freshness", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of MagnitudeScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the magnitude scoring function. </param>
        /// <returns> A new <see cref="Models.MagnitudeScoringFunction"/> instance for mocking. </returns>
        public static MagnitudeScoringFunction MagnitudeScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, MagnitudeScoringParameters parameters = null)
        {
            return new MagnitudeScoringFunction("magnitude", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of MagnitudeScoringParameters. </summary>
        /// <param name="boostingRangeStart"> The field value at which boosting starts. </param>
        /// <param name="boostingRangeEnd"> The field value at which boosting ends. </param>
        /// <param name="shouldBoostBeyondRangeByConstant"> A value indicating whether to apply a constant boost for field values beyond the range end value; default is false. </param>
        /// <returns> A new <see cref="Models.MagnitudeScoringParameters"/> instance for mocking. </returns>
        public static MagnitudeScoringParameters MagnitudeScoringParameters(double boostingRangeStart = default, double boostingRangeEnd = default, bool? shouldBoostBeyondRangeByConstant = null)
        {
            return new MagnitudeScoringParameters(boostingRangeStart, boostingRangeEnd, shouldBoostBeyondRangeByConstant);
        }

        /// <summary> Initializes a new instance of TagScoringFunction. </summary>
        /// <param name="fieldName"> The name of the field used as input to the scoring function. </param>
        /// <param name="boost"> A multiplier for the raw score. Must be a positive number not equal to 1.0. </param>
        /// <param name="interpolation"> A value indicating how boosting will be interpolated across document scores; defaults to &quot;Linear&quot;. </param>
        /// <param name="parameters"> Parameter values for the tag scoring function. </param>
        /// <returns> A new <see cref="Models.TagScoringFunction"/> instance for mocking. </returns>
        public static TagScoringFunction TagScoringFunction(string fieldName = null, double boost = default, ScoringFunctionInterpolation? interpolation = null, TagScoringParameters parameters = null)
        {
            return new TagScoringFunction("tag", fieldName, boost, interpolation, parameters);
        }

        /// <summary> Initializes a new instance of DefaultCognitiveServicesAccount. </summary>
        /// <param name="description"> Description of the cognitive service resource attached to a skillset. </param>
        /// <returns> A new <see cref="Models.DefaultCognitiveServicesAccount"/> instance for mocking. </returns>
        public static DefaultCognitiveServicesAccount DefaultCognitiveServicesAccount(string description = null)
        {
            return new DefaultCognitiveServicesAccount("#Microsoft.Azure.Search.DefaultCognitiveServices", description);
        }

        /// <summary> Initializes a new instance of CognitiveServicesAccountKey. </summary>
        /// <param name="description"> Description of the cognitive service resource attached to a skillset. </param>
        /// <param name="key"> The key used to provision the cognitive service resource attached to a skillset. </param>
        /// <returns> A new <see cref="Models.CognitiveServicesAccountKey"/> instance for mocking. </returns>
        public static CognitiveServicesAccountKey CognitiveServicesAccountKey(string description = null, string key = null)
        {
            return new CognitiveServicesAccountKey("#Microsoft.Azure.Search.CognitiveServicesByKey", description, key);
        }

        /// <summary> Initializes a new instance of ConditionalSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <returns> A new <see cref="Models.ConditionalSkill"/> instance for mocking. </returns>
        public static ConditionalSkill ConditionalSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new ConditionalSkill("#Microsoft.Skills.Util.ConditionalSkill", name, description, context, inputs?.ToList(), outputs?.ToList());
        }

        /// <summary> Initializes a new instance of KeyPhraseExtractionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="maxKeyPhraseCount"> A number indicating how many key phrases to return. If absent, all identified key phrases will be returned. </param>
        /// <returns> A new <see cref="Models.KeyPhraseExtractionSkill"/> instance for mocking. </returns>
        public static KeyPhraseExtractionSkill KeyPhraseExtractionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, KeyPhraseExtractionSkillLanguage? defaultLanguageCode = null, int? maxKeyPhraseCount = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new KeyPhraseExtractionSkill("#Microsoft.Skills.Text.KeyPhraseExtractionSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, maxKeyPhraseCount);
        }

        /// <summary> Initializes a new instance of OcrSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="textExtractionAlgorithm"> A value indicating which algorithm to use for extracting text. Default is printed. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="shouldDetectOrientation"> A value indicating to turn orientation detection on or not. Default is false. </param>
        /// <returns> A new <see cref="Models.OcrSkill"/> instance for mocking. </returns>
        public static OcrSkill OcrSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, TextExtractionAlgorithm? textExtractionAlgorithm = null, OcrSkillLanguage? defaultLanguageCode = null, bool? shouldDetectOrientation = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new OcrSkill("#Microsoft.Skills.Vision.OcrSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), textExtractionAlgorithm, defaultLanguageCode, shouldDetectOrientation);
        }

        /// <summary> Initializes a new instance of ImageAnalysisSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="visualFeatures"> A list of visual features. </param>
        /// <param name="details"> A string indicating which domain-specific details to return. </param>
        /// <returns> A new <see cref="Models.ImageAnalysisSkill"/> instance for mocking. </returns>
        public static ImageAnalysisSkill ImageAnalysisSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, ImageAnalysisSkillLanguage? defaultLanguageCode = null, IEnumerable<VisualFeature> visualFeatures = null, IEnumerable<ImageDetail> details = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            visualFeatures ??= new List<VisualFeature>();
            details ??= new List<ImageDetail>();

            return new ImageAnalysisSkill("#Microsoft.Skills.Vision.ImageAnalysisSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, visualFeatures?.ToList(), details?.ToList());
        }

        /// <summary> Initializes a new instance of LanguageDetectionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <returns> A new <see cref="Models.LanguageDetectionSkill"/> instance for mocking. </returns>
        public static LanguageDetectionSkill LanguageDetectionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new LanguageDetectionSkill("#Microsoft.Skills.Text.LanguageDetectionSkill", name, description, context, inputs?.ToList(), outputs?.ToList());
        }

        /// <summary> Initializes a new instance of ShaperSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <returns> A new <see cref="Models.ShaperSkill"/> instance for mocking. </returns>
        public static ShaperSkill ShaperSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new ShaperSkill("#Microsoft.Skills.Util.ShaperSkill", name, description, context, inputs?.ToList(), outputs?.ToList());
        }

        /// <summary> Initializes a new instance of MergeSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="insertPreTag"> The tag indicates the start of the merged text. By default, the tag is an empty space. </param>
        /// <param name="insertPostTag"> The tag indicates the end of the merged text. By default, the tag is an empty space. </param>
        /// <returns> A new <see cref="Models.MergeSkill"/> instance for mocking. </returns>
        public static MergeSkill MergeSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, string insertPreTag = null, string insertPostTag = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new MergeSkill("#Microsoft.Skills.Text.MergeSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), insertPreTag, insertPostTag);
        }

        /// <summary> Initializes a new instance of EntityRecognitionSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="categories"> A list of entity categories that should be extracted. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="includeTypelessEntities"> Determines whether or not to include entities which are well known but don&apos;t conform to a pre-defined type. If this configuration is not set (default), set to null or set to false, entities which don&apos;t conform to one of the pre-defined types will not be surfaced. </param>
        /// <param name="minimumPrecision"> A value between 0 and 1 that be used to only include entities whose confidence score is greater than the value specified. If not set (default), or if explicitly set to null, all entities will be included. </param>
        /// <returns> A new <see cref="Models.EntityRecognitionSkill"/> instance for mocking. </returns>
        public static EntityRecognitionSkill EntityRecognitionSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, IEnumerable<EntityCategory> categories = null, EntityRecognitionSkillLanguage? defaultLanguageCode = null, bool? includeTypelessEntities = null, double? minimumPrecision = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            categories ??= new List<EntityCategory>();

            return new EntityRecognitionSkill("#Microsoft.Skills.Text.EntityRecognitionSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), categories?.ToList(), defaultLanguageCode, includeTypelessEntities, minimumPrecision);
        }

        /// <summary> Initializes a new instance of SentimentSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <returns> A new <see cref="Models.SentimentSkill"/> instance for mocking. </returns>
        public static SentimentSkill SentimentSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, SentimentSkillLanguage? defaultLanguageCode = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new SentimentSkill("#Microsoft.Skills.Text.SentimentSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode);
        }

        /// <summary> Initializes a new instance of SplitSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultLanguageCode"> A value indicating which language code to use. Default is en. </param>
        /// <param name="textSplitMode"> A value indicating which split mode to perform. </param>
        /// <param name="maximumPageLength"> The desired maximum page length. Default is 10000. </param>
        /// <returns> A new <see cref="Models.SplitSkill"/> instance for mocking. </returns>
        public static SplitSkill SplitSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, SplitSkillLanguage? defaultLanguageCode = null, TextSplitMode? textSplitMode = null, int? maximumPageLength = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new SplitSkill("#Microsoft.Skills.Text.SplitSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultLanguageCode, textSplitMode, maximumPageLength);
        }

        /// <summary> Initializes a new instance of TextTranslationSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="defaultToLanguageCode"> The language code to translate documents into for documents that don&apos;t specify the to language explicitly. </param>
        /// <param name="defaultFromLanguageCode"> The language code to translate documents from for documents that don&apos;t specify the from language explicitly. </param>
        /// <param name="suggestedFrom"> The language code to translate documents from when neither the fromLanguageCode input nor the defaultFromLanguageCode parameter are provided, and the automatic language detection is unsuccessful. Default is en. </param>
        /// <returns> A new <see cref="Models.TextTranslationSkill"/> instance for mocking. </returns>
        public static TextTranslationSkill TextTranslationSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, TextTranslationSkillLanguage defaultToLanguageCode = default, TextTranslationSkillLanguage? defaultFromLanguageCode = null, TextTranslationSkillLanguage? suggestedFrom = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();

            return new TextTranslationSkill("#Microsoft.Skills.Text.TranslationSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), defaultToLanguageCode, defaultFromLanguageCode, suggestedFrom);
        }

        /// <summary> Initializes a new instance of WebApiSkill. </summary>
        /// <param name="name"> The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character &apos;#&apos;. </param>
        /// <param name="description"> The description of the skill which describes the inputs, outputs, and usage of the skill. </param>
        /// <param name="context"> Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. </param>
        /// <param name="inputs"> Inputs of the skills could be a column in the source data set, or the output of an upstream skill. </param>
        /// <param name="outputs"> The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. </param>
        /// <param name="uri"> The url for the Web API. </param>
        /// <param name="httpHeaders"> The headers required to make the http request. </param>
        /// <param name="httpMethod"> The method for the http request. </param>
        /// <param name="timeout"> The desired timeout for the request. Default is 30 seconds. </param>
        /// <param name="batchSize"> The desired batch size which indicates number of documents. </param>
        /// <param name="degreeOfParallelism"> If set, the number of parallel calls that can be made to the Web API. </param>
        /// <returns> A new <see cref="Models.WebApiSkill"/> instance for mocking. </returns>
        public static WebApiSkill WebApiSkill(string name = null, string description = null, string context = null, IEnumerable<InputFieldMappingEntry> inputs = null, IEnumerable<OutputFieldMappingEntry> outputs = null, string uri = null, IDictionary<string, string> httpHeaders = null, string httpMethod = null, TimeSpan? timeout = null, int? batchSize = null, int? degreeOfParallelism = null)
        {
            inputs ??= new List<InputFieldMappingEntry>();
            outputs ??= new List<OutputFieldMappingEntry>();
            httpHeaders ??= new Dictionary<string, string>();

            return new WebApiSkill("#Microsoft.Skills.Custom.WebApiSkill", name, description, context, inputs?.ToList(), outputs?.ToList(), uri, httpHeaders, httpMethod, timeout, batchSize, degreeOfParallelism);
        }
    }
}
